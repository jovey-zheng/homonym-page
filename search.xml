<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2F2017%2F06%2F15%2Funderstand-closure%2F</url>
    <content type="text"><![CDATA[闭包 是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。 作用域闭包的一个重点在于作用域，在 JavaScript 中变量的作用域分两种：全局变量与局部变量，首先让我们来了解一下： 12345678910111213var _global = 1; // 全局变量function print() &#123; var _internal = 2; // 局部变量 console.log(_global); // 1 console.log(_internal); // 2 return _internal;&#125;print();console.log(_global); // 1console.log(_internal); // ReferenceError: _internal is not defined 此时我们可以看到，在函数内部是可以直接读取全局变量的。但当我们在外部想访问内部变量时，就会报错，因为在函数体外部时无法访问函数内部的变量的。 需要注意的是，当在函数内部定义变量时没用使用 var 等声明变量，那么它实际上会成为一个全局变量： 12345function print() &#123; _internal = 2;&#125;console.log(_internal); // 2 从内存中解释，变量的声明都存在栈中，而在 JavaScript 中存在垃圾回收机制（garbage collection），当一个函数执行完返回之后，它的内存会被自动回收，此时函数内部的变量都会被销毁。 那么我们有什么方法可以保存这一内存，并且在外部访问函数内部的变量呢 —— 闭包。 闭包在正常情况下，我们在外部时无法修改函数内部变量的值： 12345678910// 场景 1function print(x) &#123; var _internal = 1; console.log(_internal + 1);&#125;print(1); // 2// ...print(1); // 2 我们可以看到，无论 print() 调用多少次，打印的值都是 2，_internal 的值都是 1。 这是因为 JavaScript 中的垃圾回收机制，在多次调用 print() 时，每一次都需要回收前一次的内存，之后再次申请新内存，因此 _internal 无法在内存中继续保存。 换而言之，在每次调用 print() 时都需要为其和内部的变量申请新的内存空间，第一次 _internal 的内存地址可能为 0x...1，在函数调用完成之后，这块内存将被释放，再次调用时 _internal 的内存地址可能就是 0x...2 了。因此它无法再内存中被保存下来。 那么我们需要在外部使用函数内部的变量时，就需要在函数内部再声明一个函数，并将其返回： 12345678910function print() &#123; var _internal = 1; return function log() &#123; console.log(_internal); &#125;&#125;var test = print();test(); // 1 此时，我们已经可以从外部访问 print() 函数内部的变量了。 当我们需要对 print() 函数内部的 _internal 的值进行修改时，我们可以给它另外一个函数： 123456789101112131415161718// 场景 2var add;function print() &#123; var _internal = 1; add = function(x) &#123; _internal += x; &#125; return function log() &#123; console.log(_internal); &#125;&#125;var test = print();test(); // 1add(1);test(); // 2 经过上述可以看出，函数 print() 在经过 add() 运行之后，_internal 的值分别为 1 和 2，这就说明了 _internal 始终保存在内存中，并没有在 var test = print(); 调用时被回收。 这是因为 print() 内的 log() 作为返回值，被赋给 test 这个全局变量，因此 log() 始终在内存中。而 log() 依赖 print() 并且可以访问 _internal，所以 print() 也始终在内存中，而且在 var test = print(); 调用时没有被回收。 换而言之，当 _internal 在声明的时候分配了内存，我们可以将其内存地址表示为 0x...1，在 print() 函数被调用之后应该会被回收，但是由于上述原因，没有被回收，它的值将继续保留在地址为 0x...1 中。在外部可以使用指针去寻址，并取得其值。 其他例子在循环体中，我们可能遇到： 1234567891011121314151617function loopA() &#123; var arr = []; for(var i = 0; i &lt; 10; i++) &#123; arr[i] = function() &#123; return i; &#125; &#125; return arr;&#125;var test = loopA();test[0](); // 10test[1](); // 10// ...test[9](); // 10 在上述例子中，我们需要他们执行不同的参数得到不同的值。但是一共创建了 10 次匿名函数，，他们都是共享同一个环境的。在匿名函数执行之前，循环早已完成，此时的匿名函数一局指向循环体中的最后一个值了。 解决方案 1：在 es6 中我们可以使用 let 声明： 1234567891011121314151617function loopA() &#123; var arr = []; for(let i = 0; i &lt; 10; i++) &#123; arr[i] = function() &#123; return i; &#125; &#125; return arr;&#125;var test = loopA();test[0](); // 0test[1](); // 1// ...test[9](); // 9 解决方案 2：将函数声明放在循环体外部： 1234567891011121314151617function loopA() &#123; var arr = []; var func = function(n) &#123; return n; &#125; for(var i = 0; i &lt; 10; i++) &#123; arr[i] = func(i) &#125; return arr;&#125;var test = loopA();test[0]; // 0test[1]; // 1test[9]; // 9 解决方案 3： 12345678910111213141516function loopA() &#123; var arr = []; for(var i = 0; i &lt; 10; i++) &#123; arr[i] = (function(i) &#123; return i; &#125;)(i) &#125; return arr;&#125;var test = loopA();test[0]; // 0test[1]; // 1test[9]; // 9 其他解决方案请看参考 弊端 内存泄漏：由于闭包会使得函数内部的变量都被保存在内存中，不会被销毁，内存消耗很大。因此需要在退出函数之前，将不使用的变量都删除。 会修改函数内部变量的值。 总结闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。 参考百度百科 - 闭包Wikipedia - Closure学习 Javascript 闭包（Closure）MDN - 闭包深入理解闭包系列第二篇——从执行环境角度看闭包深入理解闭包系列第四篇——常见的一个循环和闭包的错误详解深入理解javascript原型和闭包（15）——闭包]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>closure</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用的 CSS — 贝塞尔曲线(cubic-bezier)]]></title>
    <url>%2F2016%2F03%2F16%2Fcss-cubic-bezier%2F</url>
    <content type="text"><![CDATA[前言在了解 cubic-bezier 之前，你需要对 CSS3 中的动画效果有所认识，它是 animation-timing-function 和 transition-timing-function 中一个重要的内容。 本体简介cubic-bezier 又称三次贝塞尔，主要是为 animation 生成速度曲线的函数，规定是 cubic-bezier(&lt;x1&gt;, &lt;y1&gt;, &lt;x2&gt;, &lt;y2&gt;)。 我们可以从下图中简要理解一下 cubic-bezier： 从上图我们需要知道的是 cubic-bezier 的取值范围: P0：默认值 (0, 0) P1：动态取值 (x1, y1) P2：动态取值 (x2, y2) P3：默认值 (1, 1) 我们需要关注的是 P1 和 P2 两点的取值，而其中 X 轴的取值范围是 0 到 1，当取值超出范围时 cubic-bezier 将失效；Y 轴的取值没有规定，当然也毋须过大。 最直接的理解是，将以一条直线放在范围只有 1 的坐标轴中，并从中间拿出两个点来拉扯（X 轴的取值区间是 [0, 1]，Y 轴任意），最后形成的曲线就是动画的速度曲线。 使用在测试例子中：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .animation &#123; width: 50px; height: 50px; background-color: #ed3; -webkit-transition: all 2s; -o-transition: all 2s; transition: all 2s; &#125; .animation:hover &#123; -webkit-transform: translateX(100px); -ms-transform: translateX(100px); -o-transform: translateX(100px); transform: translateX(100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="animation"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们可以在浏览器中看到，当鼠标移到元素上时，元素开始向右移动，开始比较慢，之后则比较快，移开时按原曲线回到原点。 在例子中，当我们不为 transition 添加 cubic-bezier 或是其他 timing-function 时，默认的速度曲线是 ease，此时的速度曲线是： 那么让我们在代码中加入 cubic-bezier(.17, .86, .73, .14)：12345678....animation &#123; ... -webkit-transition: all 2s cubic-bezier(.17, .86, .73, .14); -o-transition: all 2s cubic-bezier(.17, .86, .73, .14); transition: all 2s cubic-bezier(.17, .86, .73, .14);&#125;... 再刷新页面观察效果，会看到动画在执行过程中有一段很缓慢的移动，前后的速度相似，此时的运动曲线是： 几个常用的固定值对应的 cubic-bezier 值以及速度曲线 ease：cubic-bezier(.25, .1, .25, 1) liner：cubic-bezier(0, 0, 1, 1) / cubic-bezier(1, 1, 0, 0) ease-in：cubic-bezier(.42, 0, 1, 1) ease-out：cubic-bezier(0, 0, .58, 1) ease-in-out：cubic-bezier(.42, 0, .58, 1) In Out . Back（来回的缓冲效果）：cubic-bezier(0.68, -0.55, 0.27, 1.55) 效果参考文章所提到的动画效果可以在下面站点中看到，当然你也可以大胆尝试： 英文版在线预览（Lea Verou） 中文版在线预览（更多效果） 在线生成系列 作者的《Loading》库 参考MDNW3School]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>cubic-bezier</tag>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 构建博客 - NexT 主题浅谈]]></title>
    <url>%2F2016%2F03%2F03%2Fhexo-theme-next-brief-talk%2F</url>
    <content type="text"><![CDATA[利用 Github 所提供的 Github Page 去构建静态的网站已经变得越来越流行，如果还不了解怎么入门，可以阅读我之前的一篇文章「使用Hexo + Next搭建静态博客」。当然构建博客的方法不是只有一种，你也可以尝试其他方法，而本文主要是针对 Hexo 去叙述的。 可能看过「使用 Hexo + Next 搭建静态博客」这篇文章的同学都已经构建好了属于自己的博客了，那么接下来要说的就是关于 NexT 主题中遇到的一些问题和提示。 关于 RSS很多同学在看到别人的博客时，都会发现有订阅的功能（即 RSS），但无奈官方介绍比较少，所以无从下手。 那么下面将教大家如何去做： 准备你需要安装一个 Hexo 插件： 1$ npm install --save hexo-generator-feed 配置接下来需要在 _config.yml 中配置一下，在 root 目录下的 _config.yml 中添加： 1234# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后在主题文件夹的 _config.yml 中配置：1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 生成 RSS Feed配置完之后在 CLI 中运行：1$ hexo g 重新生成一次，你会在 ./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 最后你可以看到： 修改文件后不生效 有时候会发现，明明修改了文件的代码，然而没有生效。 其实不是没有生效，而是静态文件没有更新，此时你需要执行：1$ hexo clean 然后执行：1$hexo g 重新生成一次即可。 社交链接图标说明一下，这些图标都是出自 FontAwesome - 4.4.0，所以你可以根据自己的需求去修改图标。 实际效果： 有的同学会发现自己的图标是个地球： 需要配置的是主题文件夹下的 _config.yml，注意：命名需要一致，包括大小写：1234567891011121314151617# Social linkssocial: GitHub: https://github.com/XXX Twitter: https://twitter.com/XXX Weibo: http://weibo.com/XXX Facebook: https://www.facebook.com/XXX JianShu: http://www.jianshu.com/XXX# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo Facebook: facebook-square JianShu: heartbeat 阅读次数简单介绍一下此功能的做法。 准备需要在 LeanCloud 申请一个帐号，进行一番配置后拿到 AppID 和 AppKey。 配置然后在主题文件夹下的 _config.yml 中配置： 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: XXX app_key: XXX 具体可以阅读这篇文章，里面的介绍非常详细！ 最后 文章将持续更新，有任何疑问和建议可以在下面评论。]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 入门实践]]></title>
    <url>%2F2016%2F01%2F26%2Freact-entry-practice%2F</url>
    <content type="text"><![CDATA[在写这篇文章之前，我已经接触 React 有大半年了。在初步学习 React 之后就正式应用到项目中，当时就想把自己的一些想法写出来分享一下，无奈不太会写文章，再则时间不是很充裕，所以也就搁下了。本篇文章比较基础，没有深入的分析，大神们轻看。废话就不多说了，那么让我们来进入正题。 简介首先想要介绍的是 React，看到这篇文章的朋友想必都有一些关于 React 的了解了，但对于刚接触的新人而言，在这就要简要地介绍一下了。然后就是关于使用 React 构建一个简单单页应用（下文用 SPA 代替，Single Page Application）的一些介绍和讲解。 关于 ReactReact 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。（更多相关介绍请看这） 特点： 仅仅只是 UI 虚拟 DOM：最大限度减少与 DOM 的交互（类似于使用 jQuery 操作 DOM） 单向数据流：很大程度减少了重复代码的使用 组件化： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 生命周期： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 正题那么进入正题，花了点时间去写一个简单的 SPA，也算是一个比较完整 React 骨架，但不包括测试（测试的教程可以看这个），相关源码可以查看 react-start-kit。 接下来看看我们这个项目的构建需要用到些什么： react redux webpack react-router ant design babel… 还有一些没有列举出来，具体可以看仓库源码的 package.json。其中的详细介绍会在文尾列出一些我所看过的文章或是官方介绍。 配置项Webpack说到 React 项目的构建就不得不提 Webpack 这个神器。构建工具有很多，例如 Grunt，Gulp，Brunch 等，相比这些构建工具，Webpack 感觉就是和 React 不谋而合，尤其是 react-hot-loader 这样的神器（热加载），让 Webpack 成为最主流的 React 构建工具。 关于 Webpack 的特性以及介绍这里就不赘述了，我们可以从下图看出 Webpack 的作用： 接着我们从项目代码中来看 Webpack。1234567entry: &#123; app: [__dirname + &apos;/src/index&apos;],&#125;,output: &#123; path: __dirname + &apos;/_dist&apos;, filename: &apos;[name]_[hash].js&apos;,&#125; 这部分主要是指定入口和出口文件。entry 作为项目的入口文件；output 作为文件编译后的出口，其中 path 代表输出的路径，filename 代表文件名称，而 [name]_[hash] 保证了浏览器不会存在缓存（即修改文件后效果不生效）。 1234567891011121314151617181920212223module: &#123; loaders: [&#123; test: /\.js$/, loaders: [&apos;babel&apos;], exclude: /node_modules/, &#125;, &#123; test: /\.css$/, loaders: [&apos;style&apos;, &apos;css&apos;], include: /components/, &#125;, &#123; test: /\.(jpe?g|png|gif|svg|ico)/i, loader: &apos;file&apos;, &#125;, &#123; test: /\.(ttf|eot|svg|woff|woff2)/, loader: &apos;file&apos;, &#125;, &#123; test: /\.(pdf)/, loader: &apos;file&apos;, &#125;, &#123; test: /\.(swf|xap)/, loader: &apos;file&apos;, &#125;],&#125; 而这部分会帮助我们去处理不同类型的文件，其中 test 就是文件的后缀，loaders 是“转译器”，include 是指定文件的目录，exclude 是排除某个目录。我们可以看出，所有的 .js 文件都会通过 babel 去转译，也就是我们在项目中使用 ES6+ 语法会通过 babel 转译成浏览器可以识别的 ES5 代码。 最后配置好的 config 是这样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; app: [__dirname + &apos;/src/index&apos;], &#125;, output: &#123; path: __dirname + &apos;/_dist&apos;, filename: &apos;[name]_[hash].js&apos;, &#125;, resolve: &#123; root: [ __dirname + &apos;/src&apos;, __dirname + &apos;/node_modules&apos;, __dirname, ], extensions: [&apos;&apos;, &apos;.js&apos;], &#125;, module: &#123; loaders: [&#123; test: /\.js$/, loaders: [&apos;babel&apos;], exclude: /node_modules/, &#125;, &#123; test: /\.css$/, loaders: [&apos;style&apos;, &apos;css&apos;], include: /components/, &#125;, &#123; test: /\.(jpe?g|png|gif|svg|ico)/i, loader: &apos;file&apos;, &#125;, &#123; test: /\.(ttf|eot|svg|woff|woff2)/, loader: &apos;file&apos;, &#125;, &#123; test: /\.(pdf)/, loader: &apos;file&apos;, &#125;, &#123; test: /\.(swf|xap)/, loader: &apos;file&apos;, &#125;], &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: __dirname + &apos;/src/index.html&apos;, favicon: __dirname + &apos;/src/favicon.ico&apos;, inject: false, &#125;), ],&#125;; Express 服务器启动Node.js web 应用开发框架 Express 作为项目的 web 服务器，有 Node.js 开发经验的同学应该挺熟悉的了，这里也不多做赘述。 最终的启动代码是这样的：1234567891011121314151617181920var express = require(&apos;express&apos;);var webpack = require(&apos;webpack&apos;);var webpackConfig = require(&apos;./webpack.development&apos;);var app = express();var compiler = webpack(webpackConfig);app.use(require(&apos;webpack-dev-middleware&apos;)(compiler, &#123; stats: &#123; colors: true, &#125;,&#125;));app.use(require(&apos;webpack-hot-middleware&apos;)(compiler)); //热加载app.listen(process.env.PORT, function(err) &#123; //在没有端口的情况下，会自动给出一个随机端口 if (err) &#123; console.log(err); &#125;&#125;); 为了方便我们的访问，项目使用了 minihost 进行启动，方便快捷。值得一提的是，使用 h -- npm start 命令启动时，访问的是项目文件夹的名称作为链接，例如项目叫 myproject，那么此时可以访问 myproject.t.t。 Redux对于复杂的 SPA，状态（state）管理非常重要。state 可能包括：服务端的响应数据、本地对响应数据的缓存、本地创建的数据（比如，表单数据）以及一些 UI 的状态信息（比如，路由、选中的 tab、是否显示下拉列表、页码控制等等）。如果 state 变化不可预测，就会难于调试（state 不易重现，很难复现一些 bug）和不易于扩展（比如，优化更新渲染、服务端渲染、路由切换时获取数据等等）。 state 为单一对象，使得 Redux 只需要维护一棵状态树，服务端很容易初始化状态，易于服务器渲染。state 只能通过 dispatch(action) 来触发更新，更新逻辑由 reducer 来执行。 在使用 Redux 后，state 就变得很容易维护，而且数据流非常清晰，容易解决遇到的 BUG。 我们可以看下图来简要地理解 Redux： 我们可以在项目中看到的结构是：1234567891011├─store├─actions├─reducers├─constants├─helpers├─components├─app.js├─favicon.ico├─index.html├─index.js└─routes.js 最终我们的 store 是：12345678910111213141516171819202122232425262728293031323334import &#123;createStore, applyMiddleware, combineReducers, compose&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import &#123;reduxReactRouter&#125; from &apos;redux-router&apos;;import createHistory from &apos;history/lib/createHashHistory&apos;;import routes from &apos;../routes&apos;;import * as reducers from &apos;../reducers&apos;;let middlewares = [thunk];if (process.env.NODE_ENV === &apos;development&apos;) &#123; //在开发环境下可以看到 state 的 log const logger = require(&apos;redux-logger&apos;); middlewares = [...middlewares, logger];&#125;const finalCreateStore = compose( //组合多个函数 applyMiddleware(...middlewares), reduxReactRouter(&#123;routes, createHistory&#125;),)(createStore); //创建 store 来管理所有的 stateexport default function configureStore(initialState) &#123; const reducer = combineReducers(reducers); //把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数 const store = finalCreateStore(reducer, initialState); if (process.env.NODE_ENV === &apos;development&apos; &amp;&amp; module.hot) &#123; //开发环境下的热加载 module.hot.accept(&apos;../reducers&apos;, () =&gt; &#123; const nextReducers = require(&apos;../reducers&apos;); const nextReducer = combineReducers(nextReducers); store.replaceReducer(nextReducer); &#125;); &#125; return store;&#125; 获取 state 需要在组件中调用 connect 函数，可以自行定义需要获取的 state。（这用于区分展示型和容器型组件）123456789...@connect( state =&gt; (&#123; data: state.data &#125;))export default class ComponentOne extends Component &#123; ...&#125; 注意：connect 必须紧跟 component 的定义，不然会报错。 Router为项目添加路由系统，使用了 react-router 来管理路由。在开发项目的时候，比较推荐的做法是使用路由去跳转页面，并且创建 store 的同时我们就把 router 加入其中，然后我们根据路由的变化去更新视图。 我们可以看看路由的源码：1234567891011import React from &apos;react&apos;;import Route from &apos;react-router/lib/Route&apos;; //import &#123;Route&#125; from &apos;react-router&apos;;import Base from &apos;components/base/Base&apos;;import Home from &apos;components/home/Home&apos;;export default ( &lt;Route component=&#123;Base&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt; &lt;/Route&gt;); path 是跳转路径，component 是与路径相匹配的组件。 Ant Design由蚂蚁金服技术部出品的一个 UI 设计语言，也是项目中所用到的 UI 组件库。 特性： Designed as Ant Design，提炼和服务企业级中后台产品的交互语言和视觉风格 React Component 上精心封装的高质量 UI 库 基于 npm + webpack + babel 的工作流，支持 ES2015 选择理由： 有很好的技术支持 简洁的样式 基本涵盖常用组件… 简单的 Component组件作为 React 渲染的一个基本组成，我们通常把它们分为两类，容器型和展示型。相较于容器型，展示型是通过容器型传递 props 来获取数据，而容器型可以直接从 store 中获取，处理并传递给下级组件。 在实际应用中会发现，定义一个容器型组件负责处理数据，然后分发给下级展示型组件，当需要更新数据时，那么容器型组件发生变化会引起下级展示型组件的变化，这样就对我们业务上造成了一定的困扰（在不需要更新的部分组件上也发生了更新）。因此，我们选择在需要获取数据的组件中使用 connect，这样则会方便很多（感觉有些违反规则）。 在项目中我们会这么定义组件：12345678910111213141516171819import React, &#123;Component&#125; from &apos;react&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import Presentational from &apos;components/common/Presentational&apos;;@connect( state =&gt; (&#123; data: state.data &#125;))export default class Container extends Component &#123; render() &#123; const &#123;data&#125; = this.props; return ( &lt;Presentational data=&#123;data&#125; /&gt; ) &#125;&#125; 上面是可以从 store 获取数据的组件，并嵌套另一个组件，将数据传递给它。123456789101112131415161718import React, &#123;Component, PropTypes&#125; from &apos;react&apos;;export default class Presentational extends Component &#123; static propTypes = &#123; data: PropTypes.string, &#125; render() &#123; const &#123;data&#125; = this.props; return ( &lt;div&gt; &#123;data&#125; &lt;/div&gt; ) &#125;&#125; 获取上一个组件传递过来的数据，并展示出来。 总结这是一篇科普文（哈哈~囧），并没有深入去分析各项技术的具体内容，希望能帮助刚入手 React 的新手们。实践项目的源码可以在 react-start-kit 看到，你可以下载这个项目进行自己的一些探索和开发。还在努力探索中，文中有措辞不当或是疏漏，欢迎提出意见和建议。 参考react 官网Babel 官网redux 介绍redux 中文文档Ant design 官网React 入门实例教程react-router 中文文档Webpack 傻瓜式指南（一）CSS Modules 详解及 React 中实践一看就懂的 ReactJs 入门教程（精华版）深入浅出React（二）：React开发神器Webpack]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>入门</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 测试驱动教程]]></title>
    <url>%2F2016%2F01%2F21%2Ftest-driven-react-tutorial%2F</url>
    <content type="text"><![CDATA[测试是开发周期中的一个重要组成部分。没有测试的代码被称为：遗留代码。对于我而言，第一次学习 React 和 JavaScript 的时候，感到很有压力。如果你也是刚开始学习 JS/React，并加入他们的社区，那么也可能会有相同的感觉。想到的会是： 我应该用哪一个构建工具？ 哪一个测试框架比较好？ 我应该学习哪种流模式？ 我需要用到流吗？ 为了解决这些烦恼，我决定写这篇文章。经过几个小时的博客文章阅读，查阅 JS 开发者的源码，还有参加 Florida 的 JSConf，终于让我找到了自己的测试“槽”。开始让我觉得没有经过测试的 React 程序代码是如此的不标准和凌乱。我想活在一个没有这种感觉的世界，但后来想想，这是不对的。 本教程所有的代码都可以在我的 github 仓库中找到。 让我们开始吧！ 设置 Webpack本教程不是一个教如何使用 webpack，所以我不会详细说，但重要的是要了解基本的东西。Webpack 就像 Rails 中的 Assets Pipeline 一样。在基础层面上而言，在运行 react 应用时，会在处理你的代码和服务的前后，只生成一个 bundle.js 在客户端。 因为它是一个非常强大的工具，所以我们会常常用到。在开始，Webpack 的功能可能会吓到你，但我建议你坚持使用下去，一旦你了解了其中的原理，就会觉得得心应手。而你只需给它一个机会去表现。 通常我们不会喜欢那些我们不会的，或是害怕的。然而，一旦你克服初始不适并开始理解它，总会变得很有趣。事实上，这正是我对测试的感受。当开始时讨厌它，在熟悉后喜欢它 :-) 如果感兴趣，这里有一些资源来更多地了解关于 webpack： Webpack Cookbook（使用的是 Babel 5，但对于学习 Webpack 的基本原理而言还是很有用的） Webpack 初学者可以看这篇文章 Pete Hunts 所写的 Webpack How-to 注意：如果要持续随本教程实验，建议使用 Node 版本为 v5.1.0。当然版本 &gt;4 的也是可以的。 首先，安装所有关于 webpack 和 babel 的依赖。Babel 是一个转译器，允许你在开发时使用 ES6（es2015）和 ES7 的特性，然后将这些代码转译成浏览器可以识别的 ES5 代码。 12345mkdir tdd_reactcd tdd_reactnpm init # follow along with normal npm init to set up projectnpm i babel-loader babel-core webpack --save-dev npm i 是 npm install 的别名。 接下来，让我们设置项目的路径和创建一个 webpack.config.js 文件： 12345mkdir src # where all our source code will livetouch src/main.js # this will be the entry point for our webpack bundlingmkdir test # place to store all our testsmkdir dist # this is where the bundled javascript from webpack will gotouch webpack.config.js # our webpack configuration file 初始化的 webpack config 会很小。阅读这些注释，理解下发生了什么： 123456789101112131415161718192021// our webpack.config.js file located in project rootvar webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;); // a useful node path helper libraryvar config = &#123; entry: [&apos;./src/main.js&apos;], // the entry point for our app output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // store the bundled output in dist/bundle.js filename: &apos;bundle.js&apos; // specifying file name for our compiled assets &#125;, module: &#123; loaders: [ // telling webpack which loaders we want to use. For now just run the // code through the babel-loader. &apos;babel&apos; is an alias for babel-loader &#123; test: /\.js$/, loaders: [&apos;babel&apos;], exclude: /node_modules/ &#125; ] &#125;&#125;module.exports = config; 为了让 babel 更好地工作，我们需要定义哪个 presets 是我们需要用到的。让我们继续，并且安装 React 和 ES6 预处理所需的东西： 1npm i babel-preset-react babel-preset-es2015 --save-dev 现在我们有一些选项。在 webpack config 文件中，会告诉你哪一块是做 bebel 预处理的： 12345678910loaders: [ &#123; test: /\.js$/, loaders: [&apos;babel&apos;], exclude: /node_modules/, query: &#123; presets: [&apos;react&apos;, &apos;es2015&apos;] &#125; &#125;] 另外的方法是将他们存在 .babelrc 文件中，这也用在我的项目中。将 babel 预处理存储在 .babelrc 中，对于以后的开发者而言，更容易去找到哪个 babel 预处理是可用的。此外，当我们将 Karma 设置到 webpack 之后，因为 .babelrc 文件的存在，我们就不再需要其他的预处理配置了。 12# inside our project roottouch .babelrc 将下面这段粘贴到预处理文件中： 1234# .babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; 为了确认它能否工作，让我们在 main.js 中加入一些 react 代码，并看看所有的包是否正常。接着安装 React 和 React DOM： 1npm i react react-dom -S 使用 -S 是 --save 的别名。 创建第一个 React 组件： 1234567891011# src/main.jsimport React, &#123; Component &#125; from &apos;react&apos;;import &#123; render &#125; from &apos;react-dom&apos;;class Root extends Component &#123; render() &#123; return &lt;h1&gt; Hello World &lt;/h1&gt;; &#125;&#125;render(&lt;Root /&gt;, document.getElementById(&apos;root&apos;)); 聪明的读者就会察觉我们并没有在根部创建一个 index.html 文件。让我们继续，当 bundle.js 编译后，将其放到 /dist 文件夹中： 123456789101112# /dist/index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 非常棒，让我们继续。最后，我们可以运行 webpack，看看一切是否正常。如果你没有全局安装 webpack（npm i webpack -g），你也可以用 node modules 方式进行启动： 1./node_modules/.bin/webpack Webpack 将默认情况下寻找一个配置名称为 webpack.config.js。如果你高兴，也可以通过不同 webpack config 作为参数传入。 在 package.json 中创建一个别名，来完成构建工作： 12345# package.json... other stuff&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125; 接下来让 webpack-dev-server 提升开发体验： 1npm i webpack-dev-server --save-dev 将 webpack dev server 的入口加入到 webpack.config.js 中： 1234567... rest of config entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, &apos;./src/main.js&apos; ],... rest of config 让 script 运行在开发服务器上： 123456# package.json... other stuffscripts: &#123; &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base dist&quot;, &quot;build&quot;: &quot;webpack&quot;&#125; 在 script 中使用了 --content-base 标记，告诉 webpack 我们想服务于 /dist 文件夹。我们还定义了 3000 端口，使得更像是 Rails 开发的体验。 最后，在 webpack 配置文件中添加一个 resolve 标记，使进口文件看起来更直观。下面就是配置文件最终的样子： 123456789101112131415161718192021222324252627282930313233343536373839var webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;);var config = &#123; entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, &apos;./src/main.js&apos; ], resolve: &#123; root: [ // allows us to import modules as if /src was the root. // so I can do: import Comment from &apos;components/Comment&apos; // instead of: import Comment from &apos;../components/Comment&apos; or whatever relative path would be path.resolve(__dirname, &apos;./src&apos;) ], // allows you to require without the .js at end of filenames // import Component from &apos;component&apos; vs. import Component from &apos;component.js&apos; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.jsx&apos;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.js?$/, // dont run node_modules or bower_components through babel loader exclude: /(node_modules|bower_components)/, // babel is alias for babel-loader // npm i babel-core babel-loader --save-dev loader: &apos;babel&apos; &#125; ], &#125;&#125;module.exports = config; 为确保一切工作正常，让我们运行开发服务器，并且确认我们在屏幕上看到 “Hello World”。 12npm run devopen http://localhost:3000 你应该看到的是这样的： 设置 Mocha，Chai，Sinon 和 EnzymeMocha：将用于运行我们的测试。Chai：是我们期待的库。应用非常广泛，允许使用 RSpec 一样的语法。Sinon：将服务于 mocks/stubs/spies.Enzyme：将用于测试我们的 React components。AirBnB 写的一个很漂亮的测试库。 安装这些包： 1npm i mocha chai sinon --save-dev 如果我们希望能够使用 ES6 编写测试，那么我们需要在运行前对代码进行转译。那么我们需要安装 babel-register： 1npm i babel-register --save-dev 加一些 npm scripts 到 package.json 中，让测试更简单： 12345678# ./package.json... rest of package.json &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha --compilers js:babel-register --recursive&quot;, &quot;test:watch&quot;: &quot;npm test -- --watch&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base dist&quot;, &#125;, 我们的测试脚本要运行 mocha，并使用 babel-register 进行转译，然后递归地查看 /test 目录。 最终，我们需要设置 Karma，因此 npm script 会变得无效，但如果不设置，它将会正常工作。npm run test:watch 将会监视程序，并在文件发生修改时重新运行。多么高效！ 确认它能工作，创建一个 hello world 测试 /tests/helloWorld.spec.js： 12345678# /test/helloWorld.spec.jsimport &#123; expect &#125; from &apos;chai&apos;;describe(&apos;hello world&apos;, () =&gt; &#123; it(&apos;works!&apos;, () =&gt; &#123; expect(true).to.be.true; &#125;);&#125;); 哇…看起来很像 RSpec！ 如果每一个测试都要引入 expect，这将变得很麻烦，因此让我们新建一个 test_helper 文件来保存这些东西： 123456# /test/test_helper.jsimport &#123; expect &#125; from &apos;chai&apos;;import sinon from &apos;sinon&apos;;global.expect = expect;global.sinon = sinon; 然后把它包括到 npm 脚本的运行套件中，并通过 --require ./test/test_helper.js 来声明： 12# package.json script section &quot;test&quot;: &quot;mocha --compilers js:babel-register --require ./test/test_helper.js --recursive&quot;, 我也添加了 sinon，因此它也可以全局可用。现在无论什么时候，我们在写一个新的测试时，都不需要手动引入 expect 和 sinon。 Enzyme现在我们所需的“普通”测试工具都已经设置好了（mocha，chai，sinon），接着让我们安装 Enzyme，并且开始测试 React component！ 安装这个包： 1npm i enzyme react-addons-test-utils --save-dev Enzyme 的重要文档可以在这里找到。如果有时间，我推荐阅读 Shallow Rendering 部分。 你会问，什么是 Shallow Rendering？ 对我们来说是一种组件调用 render 方法，得到我们可以断言的 React 元素，而无需实际安装组件到 DOM 上。更多的 React 元素请看这。 Enzyme 会将 shallow rendered 组件包裹进一个特殊的 wrapper 中，进而让我们可以测试。如果你用过 Rails，这看起来像是 Capybara 中的 page 对象。 让我们为一些合适的 &lt;Root /&gt; 组件进行 TDD 的驱动开发。 这个 Root 组件会是一个 container，意味着在应用中它可以控制 state 的处理。学习 React 中“智能”和“笨拙”组件之间的差异，对于应用程序体系结构是很重要的。这篇文章很好地解释了它们。 1234567891011121314151617181920212223242526# /tests/containers/Root.spec.jsimport React from &apos;react&apos;; // required to get test to work. we can get around this later with more configurationimport &#123; shallow &#125; from &apos;enzyme&apos;; // method from enzyme which allows us to do shallow renderimport Root from &apos;../../src/containers/Root&apos;; // import our soon to be componentdescribe(&apos;(Container) Root&apos;, () =&gt; &#123; it(&apos;renders as a &lt;div&gt;&apos;, () =&gt; &#123; const wrapper = shallow(&lt;Root /&gt;); expect(wrapper.type()).to.eql(&apos;div&apos;); &#125;); it(&apos;has style with height 100%&apos;, () =&gt; &#123; const wrapper = shallow(&lt;Root /&gt;); const expectedStyles = &#123; height: &apos;100%&apos;, background: &apos;#333&apos; &#125; expect(wrapper.prop(&apos;style&apos;)).to.eql(expectedStyles); &#125;); it(&apos;contains a header explaining the app&apos;, () =&gt; &#123; const wrapper = shallow(&lt;Root /&gt;); expect(wrapper.find(&apos;.welcome-header&apos;)).to.have.length(1); &#125;);&#125;); 如果我们用 npm test 运行测试，这会失败。因为我们没有在适当的位置创建一个根组件。因此我们可以这样做： 如果在任何时候你想看到这段代码的源代码，可以在 github 仓库 中找到 12345678910111213141516171819# /src/containers/Root.jsimport React, &#123; Component &#125; from &apos;react&apos;;const styles = &#123; height: &apos;100%&apos;, background: &apos;#333&apos;&#125;class Root extends Component &#123; render() &#123; return ( &lt;div style=&#123;styles&#125;&gt; &lt;h1 className=&apos;welcome-header&apos;&gt;Welcome to testing React!&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;export default Root; 重新运行测试就可以了。 在我们的测试中有很多重复的东西，因此我们还需要回去做一些重构。由于我们没有给 Root 传入任何的 props，那么我们可以 shallow render 它一次，然后就在一个 wrapper 中结束了我们所有的断言。很多时候给定一个特定的 props 后，我发现自己包装的部分测试会在 “sub” describe 块中，然后给一堆断言也有这些 props。如果你用过 RSpec，就类似于使用 “context” 块。 12345678910111213141516171819describe(&apos;(Container) Root&apos;, () =&gt; &#123; const wrapper = shallow(&lt;Root /&gt;); it(&apos;renders as a &lt;div&gt;&apos;, () =&gt; &#123; expect(wrapper.type()).to.eql(&apos;div&apos;); &#125;); it(&apos;has style with height 100%&apos;, () =&gt; &#123; const expectedStyles = &#123; height: &apos;100%&apos;, background: &apos;#333&apos; &#125; expect(wrapper.prop(&apos;style&apos;)).to.eql(expectedStyles); &#125;); it(&apos;contains a header explaining the app&apos;, () =&gt; &#123; expect(wrapper.find(&apos;.welcome-header&apos;)).to.have.length(1); &#125;);&#125;); 尽可能地在你的测试中使用 shallow，但偶尔也可能不用。例如，如果你要测试 React 生命周期的方法时，就需要真正地将组件安装出来。 接下来让我们测试一个组件的安装和调用函数，当它安装时，我们可以得到一些暴露在 sinon 上的信息和正在使用的 spies。 我们可以假装 Root 组件有一个子组件叫 CommentList，在安装后将调用任意的回调。当通过给定 props 组件安装时，函数被调用，因此我们就可以测试这个场景。在组件渲染时给评论列表一些 style，然后我们就可以知道 shallow render 是如何处理这些样式的了。CommentList 会在一个组件文件夹的 /src/components/CommentList.js 中。因为它不处理数据，因此完全取决于 props，换句话说它是一个纯（笨拙）组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React from &apos;react&apos;;// Once we set up Karma to run our tests through webpack// we will no longer need to have these long relative pathsimport CommentList from &apos;../../src/components/CommentList&apos;;import &#123; describeWithDOM, mount, shallow, spyLifecycle&#125; from &apos;enzyme&apos;;describe(&apos;(Component) CommentList&apos;, () =&gt; &#123; // using special describeWithDOM helper that enzyme // provides so if other devs on my team don&apos;t have JSDom set up // properly or are using old version of node it won&apos;t bork their test suite // // All of our tests that depend on mounting should go inside one of these // special describe blocks describeWithDOM(&apos;Lifecycle methods&apos;, () =&gt; &#123; it(&apos;calls componentDidMount&apos;, () =&gt; &#123; spyLifecyle(CommentList); const props = &#123; onMount: () =&gt; &#123;&#125;, // an anonymous function in ES6 arrow syntax isActive: false &#125; // using destructuring to pass props down // easily and then mounting the component mount(&lt;CommentList &#123;...props&#125; /&gt;); // CommentList&apos;s componentDidMount should have been // called once. spyLifecyle attaches sinon spys so we can // make this assertion expect( CommentList.prototype.componentDidMount.calledOnce ).to.be.true; &#125;); it(&apos;calls onMount prop once it mounts&apos;, () =&gt; &#123; // create a spy for the onMount function const props = &#123; onMount: sinon.spy() &#125;; // mount our component mount(&lt;CommentList &#123;...props&#125; /&gt;); // expect that onMount was called expect(props.onMount.calledOnce).to.be.true; &#125;); &#125;);&#125;); 还有很多，阅读这些注释可以帮助你更好地理解。看看这些实践，让测试可以通过，然后再回头看看这些测试，验证下你所理解的东西。 123456789101112131415161718192021222324# /src/components/CommentList.jsimport React, &#123; Component, PropTypes &#125; from &apos;react&apos;;const propTypes = &#123; onMount: PropTypes.func.isRequired, isActive: PropTypes.bool&#125;;class CommentList extends Component &#123; componentDidMount() &#123; this.props.onMount(); &#125; render() &#123; return ( &lt;ul&gt; &lt;li&gt; Comment One &lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;CommentList.propTypes = propTypes;export default CommentList; 运行 npm test ，现在这些套件应该可以通过测试了。 接下来让我们添加一些 shallow rendered 测试，当给定一个 isActive 的 props 时，来确保我们的组件使用了适当的 CSS class。 123456789101112131415161718192021222324252627... previous tests it(&apos;should render as a &lt;ul&gt;&apos;, () =&gt; &#123; const props = &#123; onMount: () =&gt; &#123;&#125; &#125;; const wrapper = shallow(&lt;CommentList &#123;...props&#125; /&gt;); expect(wrapper.type()).to.eql(&apos;ul&apos;); &#125;); describe(&apos;when active...&apos;, () =&gt; &#123; const wrapper = shallow( // just passing isActive is an alias for true &lt;CommentList onMount=&#123;() =&gt; &#123;&#125;&#125; isActive /&gt; ) it(&apos;should render with className active-list&apos;, () =&gt; &#123; expect(wrapper.prop(&apos;className&apos;)).to.eql(&apos;active-list&apos;); &#125;); &#125;); describe(&apos;when inactive...&apos;, () =&gt; &#123; const wrapper = shallow( &lt;CommentList onMount=&#123;() =&gt; &#123;&#125;&#125; isActive=&#123;false&#125; /&gt; ) it(&apos;should render with className inactive-list&apos;, () =&gt; &#123; expect(wrapper.prop(&apos;className&apos;)).to.eql(&apos;inactive-list&apos;); &#125;); &#125;);&#125;); 让它们通过测试： 12345678910111213141516class CommentList extends Component &#123; componentDidMount() &#123; this.props.onMount(); &#125; render() &#123; const &#123; isActive &#125; = this.props; const className = isActive ? &apos;active-list&apos; : &apos;inactive-list&apos;; return ( &lt;ul className=&#123;className&#125;&gt; &lt;li&gt; Comment One &lt;/li&gt; &lt;/ul&gt; ) &#125;&#125; 此时你应该对如何测试 react 组件已经有了一个很好的理解了。记得去阅读 Enzyme 文档来获得更多的灵感。 设置 Karma设置 Karma 可能会有些困难。坦白讲，这对我而言也是一件痛苦的工作。通常，当我开发 React 应用时，我会选择使用已经构建好的 starter kit，方便省事。我非常推荐开发时用的 starter kit。 使用 Karma 的价值在于快速测试重载，可以多浏览器测试和最重要的是 webpack 预处理。一旦我们将 Karma 设置好了，在我们运行测试程序时，不仅是只有 babel-loader，而是整个 webpack config。这为我们提供了很多便利，使得我们的测试环境与开发环境相同。 让我们开始吧… 12345678npm i karma karma-chai karma-mocha karma-webpack --save-devnpm i karma-sourcemap-loader karma-phantomjs-launcher --save-devnpm i karma-spec-reporter --save-devnpm i phantomjs --save-dev# The polyfills arn&apos;t required but will help with browser support issues# and are easy enough to include in our karma config that I figured why notnpm i babel-polyfill phantomjs-polyfill --save-dev 很多包，我知道。相信我完成这个是非常值得的。 对于我们的示例而言，我们将使用 PhantomJS。没有别的什么原因，这我在 starter kit 中已经用到了。可以按照自己的喜好使用 Chrome，Firefox 或是 Safari，甚至在 PhantomJS 之上。（这是用 Karma 的一件很酷的事） 在配置 karma 之前先安装 yargs，它能让你使用命令行参数来定制 Karma 的配置。 1npm i yargs -S 现在我们可以通过创建一个 Karma config 文件去监视我们的文件，当文件发生修改时重新运行并很快地保存。 Karma Config：1touch karma.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ./karma.config.jsvar argv = require(&apos;yargs&apos;).argv;var path = require(&apos;path&apos;);module.exports = function(config) &#123; config.set(&#123; // only use PhantomJS for our &apos;test&apos; browser browsers: [&apos;PhantomJS&apos;], // just run once by default unless --watch flag is passed singleRun: !argv.watch, // which karma frameworks do we want integrated frameworks: [&apos;mocha&apos;, &apos;chai&apos;], // displays tests in a nice readable format reporters: [&apos;spec&apos;], // include some polyfills for babel and phantomjs files: [ &apos;node_modules/babel-polyfill/dist/polyfill.js&apos;, &apos;./node_modules/phantomjs-polyfill/bind-polyfill.js&apos;, &apos;./test/**/*.js&apos; // specify files to watch for tests ], preprocessors: &#123; // these files we want to be precompiled with webpack // also run tests throug sourcemap for easier debugging [&apos;./test/**/*.js&apos;]: [&apos;webpack&apos;, &apos;sourcemap&apos;] &#125;, // A lot of people will reuse the same webpack config that they use // in development for karma but remove any production plugins like UglifyJS etc. // I chose to just re-write the config so readers can see what it needs to have webpack: &#123; devtool: &apos;inline-source-map&apos;, resolve: &#123; // allow us to import components in tests like: // import Example from &apos;components/Example&apos;; root: path.resolve(__dirname, &apos;./src&apos;), // allow us to avoid including extension name extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;], // required for enzyme to work properly alias: &#123; &apos;sinon&apos;: &apos;sinon/pkg/sinon&apos; &#125; &#125;, module: &#123; // don&apos;t run babel-loader through the sinon module noParse: [ /node_modules\/sinon\// ], // run babel loader for our tests loaders: [ &#123; test: /\.js?$/, exclude: /node_modules/, loader: &apos;babel&apos; &#125;, ], &#125;, // required for enzyme to work properly externals: &#123; &apos;jsdom&apos;: &apos;window&apos;, &apos;cheerio&apos;: &apos;window&apos;, &apos;react/lib/ExecutionEnvironment&apos;: true, &apos;react/lib/ReactContext&apos;: &apos;window&apos; &#125;, &#125;, webpackMiddleware: &#123; noInfo: true &#125;, // tell karma all the plugins we&apos;re going to be using to prevent warnings plugins: [ &apos;karma-mocha&apos;, &apos;karma-chai&apos;, &apos;karma-webpack&apos;, &apos;karma-phantomjs-launcher&apos;, &apos;karma-spec-reporter&apos;, &apos;karma-sourcemap-loader&apos; ] &#125;);&#125;; 阅读所有的注释一次或两次有助于理解这个 config 是做什么的。使用 Webpack 的一大好处是全部都是普通的 JavaScript 代码，并且我们可以“重构”配置文件。事实上，这正是绝大多数 starter kit 所做的！ 随着 Karma 设置完成，为运行测试，最后一件事就是要去更新我们的 package.json： 1234567# package.json &quot;scripts&quot; &#123; &quot;test&quot;: &quot;node_modules/.bin/karma start karma.config.js&quot;, &quot;test:dev&quot;: &quot;npm run test -- --watch&quot;, &quot;old_test&quot;: &quot;mocha --compilers js:babel-register --require ./test/test_helper.js --recursive&quot;, &quot;old_test:watch&quot;: &quot;npm test -- --watch&quot; &#125; 我建议重命名旧的测试 scripts 的前缀，用 ‘old_’ 表示。 最终的 package.json 是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;name&quot;: &quot;react-testing-starter-kit&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;React starter kit with nice testing environment set up.&quot;, &quot;main&quot;: &quot;src/main.js&quot;, &quot;directories&quot;: &#123; &quot;test&quot;: &quot;tests&quot;, &quot;src&quot;: &quot;src&quot;, &quot;dist&quot;: &quot;dist&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;react&quot;: &quot;^0.14.6&quot;, &quot;react-dom&quot;: &quot;^0.14.6&quot;, &quot;yargs&quot;: &quot;^3.31.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.4.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.1&quot;, &quot;babel-polyfill&quot;: &quot;^6.3.14&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.3.13&quot;, &quot;babel-preset-react&quot;: &quot;^6.3.13&quot;, &quot;babel-register&quot;: &quot;^6.3.13&quot;, &quot;chai&quot;: &quot;^3.4.1&quot;, &quot;enzyme&quot;: &quot;^1.2.0&quot;, &quot;json-loader&quot;: &quot;^0.5.4&quot;, &quot;karma&quot;: &quot;^0.13.19&quot;, &quot;karma-chai&quot;: &quot;^0.1.0&quot;, &quot;karma-mocha&quot;: &quot;^0.2.1&quot;, &quot;karma-phantomjs-launcher&quot;: &quot;^0.2.3&quot;, &quot;karma-sourcemap-loader&quot;: &quot;^0.3.6&quot;, &quot;karma-spec-reporter&quot;: &quot;0.0.23&quot;, &quot;karma-webpack&quot;: &quot;^1.7.0&quot;, &quot;mocha&quot;: &quot;^2.3.4&quot;, &quot;phantomjs&quot;: &quot;^1.9.19&quot;, &quot;phantomjs-polyfill&quot;: &quot;0.0.1&quot;, &quot;react-addons-test-utils&quot;: &quot;^0.14.6&quot;, &quot;sinon&quot;: &quot;^1.17.2&quot;, &quot;webpack&quot;: &quot;^1.12.11&quot;, &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;node_modules/.bin/karma start karma.config.js&quot;, &quot;test:dev&quot;: &quot;npm run test -- --watch&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base dist&quot;, &quot;old_test&quot;: &quot;mocha --compilers js:babel-register --require ./test/test_helper.js --recursive&quot;, &quot;old_test:watch&quot;: &quot;npm test -- --watch&quot; &#125;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;tbd&quot; &#125;, &quot;author&quot;: &quot;Spencer Dixon&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 在测试套件中外加 webpack 预处理，我们现在可以删除那些在测试内烦人的相对路径声明： 1234567891011121314151617// test/containers/Root.spec.jsimport React from &apos;react&apos;;import &#123; shallow &#125; from &apos;enzyme&apos;;import Root from &apos;containers/Root&apos;; // new import statement// import Root from &apos;../../src/containers/Root&apos;; // old import statement// test/components/CommentList.spec.jsimport React from &apos;react&apos;;import CommentList from &apos;components/CommentList&apos;; // new import statement// import CommentList from &apos;../../src/components/CommentList&apos;; // old import statementimport &#123; describeWithDOM, mount, shallow, spyLifecycle&#125; from &apos;enzyme&apos;; 现在使用这个 starter kit 开发，你需要输入以下这些命令去运行程序： 12npm run dev # note the addition of runnpm run test:dev # note the addition of run 如果还有什么不清楚的地方，可以在 github 上查看该源码。 结论我们已经建立了一个坚实的测试环境，可以根据你的项目具体需求去改变和发展。在下一次的文章中，我将花更多的时间在特殊场景的测试，还有如何测试 Redux，我更喜欢 flux 的实现。 虽然我只使用 React 开发了数月，但我已经爱上它了。我希望本教程可以帮助你更深入地理解一些 React 测试的最佳实践。有任何问题或评论随时联系我。测试是我们的好朋友！ 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>Tutorial</tag>
        <tag>Testing</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20 个交互非常棒的按钮代码]]></title>
    <url>%2F2015%2F12%2F24%2F20-code-snippets-for-interactive-buttons%2F</url>
    <content type="text"><![CDATA[你能想象网页中没有按钮吗？我打赌你不会。在网页中，拥有按钮并不奇怪，这些看似很小、主要以矩形表现（如导航栏，版权信息）的东西，其实是网页 UI 中基础之一。它们不仅使链接看起来更有分量、吸引人和鲜明，而且他们还能提高跳转率和用户体验，使之更方便和直观。这些 CTA （Call-to-action：行为召唤）能帮你获得更多的潜在客户和促进业务的扩展。 按钮的开发需要注意它的形状、颜色、空间、排版和前景，这些都很重要。前四个主要是依赖于网页的主题，而最后一个则是取决于你需要达成的目标。例如，你可以在用户点击后，等待的时间里在按钮上加入转轮点亮的动画；又或是，加入一些更吸引眼球的动画效果。如此一来，添加动画效果可以使按钮产生的效果最大化。那么，接下来为你介绍这 20 个很棒的按钮代码，它们能使按钮更加丰富，且用户体验超好。 波浪形按钮 作者：Nikolay Talanov 用 Canvas 和 HTML5 制作的粒子状按钮 作者：Ignacio Correia 用 Sass 制作的胶状按钮 作者：François Lesenne 3D 弹出效果的按钮 作者：Ashley Nolan “Material Design” CSS 动画效果的按钮 作者：Jon Brennecke 具有 3D 效果的按钮 作者：drus unlimited 关闭按钮效果 作者：Jonas Badalic 一些时尚的切换效果按钮 作者：Ashley Nolan 纯 CSS3 效果的按钮 作者：Overly Engineered Hover 效果 作者：Deep Jelly 按钮 作者：ayamflow Hover 效果的按钮 作者：James Power Gaming Button With Hover Effect 作者：kaigth 分享按钮 作者：Vincent Durand Flipside 作者：Hakim El Hattab 粒子按钮效果 作者：Timo Hausmann CSS3 按钮示例 作者：Volusion Services 很棒的按钮样式和效果 作者：Mary Lou 创意按钮样式 作者：Mary Lou 3D 动画效果的按钮 作者：Zachary Minner 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>button</tag>
        <tag>interactive</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 的使用中你可能不知道的 7 件事]]></title>
    <url>%2F2015%2F12%2F22%2Fcss-facts%2F</url>
    <content type="text"><![CDATA[无论你信不信，JavaScript 和 CSS 已经开始重叠，并为 CSS 增加了更多的功能。当我在写 CSS 与 JavaScript 交互中你可能不知道的 5 种方式的时候，读者对于 CSS 与 JavaScript 已经重叠的事感到很惊讶。那么今天，我会着重为你介绍 7 个可以通过 CSS 完成的任务 —— 不使用 JavaScript 或图像处理！ CSS @supports每个优秀的前端工程师都会在使用某个特性前测试一下，确保是否在浏览器中可以使用。而这类测试通常是由 JavaScript 完成的，当然，也有很多人用 Modernizr（拥有很多很好功能的测试工具）来测试特性。那么现在有一个 CSS 新的 API 可以让你去做特性测试：@supports，下面的例子将简单地教你如何使用： 12345678910111213141516171819202122/* basic usage */@supports(prop:value) &#123; /* more styles */&#125;/* real usage */@supports (display: flex) &#123; div &#123; display: flex; &#125;&#125;/* testing prefixes too */@supports (display: -webkit-flex) or (display: -moz-flex) or (display: flex) &#123; section &#123; display: -webkit-flex; display: -moz-flex; display: flex; float: none; &#125;&#125; @supports 这个新的特性也有一个相对应的 JavaScript 方式，但这个特性还在实验阶段，希望我们可以很快用到！ CSS Filters你可以写一个服务去修改图片的颜色，同时还可以把它卖给 Facebook 获得大量的钱！当然，写一个图片过滤器功能只是一个简单化的实现，并非一门科学。在 Mozilla 的第一周，我写了一个小的应用（这让我赢了比赛，BTW…就说说而已），这个应用使用了一些 JS-base 的数学方法并使用 canvas 去做图片过滤器。这很麻烦，但是现在我们可以用 CSS 的特性去完成这一功能！ 123456789/* simple filter */.myElement &#123; -webkit-filter: blur(2px);&#125;/* advanced filter */.myElement &#123; -webkit-filter: blur(2px) grayscale (.5) opacity(0.8) hue-rotate(120deg);&#125; 这类的过滤功能只是创建一个图片的原型，并且不会保存和导出来完成过滤器的功能。这对于图片管理或想处理任何一张图片来说很方便！ Demo Pointer Events 和点击事件CSS 特性中的 pointer-events 提供了一个方法，能使一个元素 disable，即在用户点击某个元素时，不触发它在 JavaScript 中写的点击事件： 12/* do nothing when clicked or activated */.disabled &#123; pointer-events: none; &#125; 1234/* this will _not_ fire because of the pointer-events: none application */document.getElementById("disabled-element").addEventListener("click", function(e) &#123; alert("Clicked!");&#125;); 在上述的例子中，由于 pointer-events 的值是 none，而使点击事件不被触发。大有用处的是，让你不必到处去检查类名或属性，来确认哪一个是 disabled 的了。 Demo Slide Down &amp; Slide UpCSS 使我们能够创建转换和动画，但通常我们需要一个 JavaScript 库帮助我们实现。例如一个比较流行的动画效果 slide up 和 silde down，大概很多人都不知道这个可以只用 CSS 实现吧！ 1234567891011121314/* slider in open state */.slider &#123; overflow-y: hidden; max-height: 500px; /* approximate max height */ transition-property: all; transition-duration: .5s; transition-timing-function: cubic-bezier(0, 1, 0.5, 1);&#125;/* close it with the "closed" class */.slider.closed &#123; max-height: 0;&#125; 很聪明地使用了 max-height 来控制元素的展开和收缩。 Demo CSS Counters我们不禁地问，“counter” 在网上意味着什么呢？但是 CSS Counters 就是另外一回事了。这个特性可以把一个 counter 加到元素中，通过 :before 或 :after ： 1234567891011121314/* initialize the counter */ol.slides &#123; counter-reset: slideNum;&#125;/* increment the counter */ol.slides &gt; li &#123; counter-increment: slideNum;&#125;/* display the counter value */ol.slides li:after &#123; content: "[" counter(slideNum) "]";&#125; 通常这个会在一些模块或是列表中用到。 Demo Unicode CSS Classes有大量的文章说明，去教你如何对 CSS 的类命名。但你应该不知道会有这样的文档，去教你用特殊字符命名你的 css 类： 123456789.ಠ_ಠ &#123; border: 1px solid #f00; background: pink;&#125;.❤ &#123; background: lightgreen; border: 1px solid green;&#125; 但请不要这么使用。 Demo CSS CirclesCSS 中的圆形 与 CSS 中的三角形一样。通过使用 border-radius 就能创建一个完美的圆形！ 123456.circle &#123; border-radius: 50%; width: 200px; height: 200px; /* width and height can be anything, as long as they're equal */&#125; 你也可以给圆形添加一些渐变效果，甚至可以添加动画。CSS 拥有更多对于图形统一的 API，当然现在你可以使用 hack 创建一个圆形。 Demo 就是这些：你可能不知道的 7 个关于 CSS 的事，一部分是临界的情况，其他一部分还是非常实用的。那么就大胆地去用它们吧！ 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>css</tag>
        <tag>features</tag>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 React 是业务需求，而不是技术需求]]></title>
    <url>%2F2015%2F12%2F15%2Fusing-react-is-a-business-decision-not-a-technology-choice%2F</url>
    <content type="text"><![CDATA[前言React 已经在开发者圈越来越流行了，并且有很多说明其技术优势的资源。然而，迁移（或是选择）一个新的框架最终归结为向所有人推销 —— 包括非开发者。这里会有一小部分工程经理或项目经理会因为它的新颖，而选择使用它来重构，更糟的是，很多团队被 JavaScript 的高生产工具搞得焦头烂额了，可悲的是向后移动项目是向前移动 web 的一部分。这篇文章并不是试图教你关于 React 的新东西，只是试着去总结以下，起点是为了向所有人说明 React 的疑惑，不仅是开发者。 总结：React 是一个为创建可组合的用户界面的库。同比其他类似的库如 Angular、Backbone、Knockout 和 Ember，React 的出现是为了解决业务问题而非技术的。接下来会为你解释 React 的重要性和对开发团队的益处。 降低风险稳定性 —— Facebook 花了很大的精力在 React 上（Newsfeed，Instagram，Messenger，Ads Marketplace 等），并且拥有专职的技术团队来维护这个项目。它的 dog-food 测试和投资都不是现有的任何一个项目能比的。除了 Facebook 内部的工程师，还有一大批 React 的爱好者。随着版本的更迭，目前在 github 上拥有 571 个贡献者（截止到 2015 年 12 月）。 正在使用 React：AirBnB，Asana，Atlassian，BBC，Chegg，CloudFlare，CNN.com，Codecademy，Coursera，Craftsy，Dailymotion，Dropbox，Expedia，Facebook，Feedly，Flipboard，HipChat，IMDb，Imgur，Instagram，Khan Academy，KISSmetrics，Mattermark，Minerva Project，Netflix，OkCupid，Rackspace，Rally Software，Ralph Lauren，Reddit，Redfin，Salesforce，Squarespace，The New York Times，Trunk Club，Twitter，Uber，University of Cincinnati，Venmo，WhatsApp，Wired，Wix，WordPress，Yahoo，Zendesk 开发效率强大的路径迁移 —— React 允许开发者可以根据自己的需求将其放到任何一个已经存在的页面上。值得注意的是，React 是需要加载一个运行时的库（React 0.14.0 的大小是 39.4 kb），因此零碎的迁移会导致页面重量的增加，直到旧版本的库被移除才会减少。 默认情况下的性能 —— React 的使用模式，让它很难写出低性能的代码。此外，自从它减少了与 DOM 的直接交互，使得它不仅可以代替现有的一些库（Angular/Backbone/Ember），也不再需要大量像 jQuery 一样的依赖，从而减少整体部署代码大小。 SEO —— SEO 是从服务器发送一个已经渲染好的页面到浏览器上。React 在设计时就考虑到了 SEO，它用 Node 可以在客户端或服务端进行渲染。其他工具允许在服务端进行渲染，但需要引入一些不稳定的 hack，同时还需要大量的人员去维护。而 React 有可能简化构建工具和减少维护成本。 提高了代码的重用 —— React 在提供良好的性能同时还可以管理组件的渲染生命周期，如此一来可以显著地提高开发人员的开发效率。通过可重用组件的创造、分配和使用，使之更简单，这样开发人员就能更好地节省使用和开发通用组件的时间。就如按钮一样的低阶元素和可折叠元素一样的高阶元素。 提高开发效率从混合资源中降低复杂度 —— React 混合了 HTML 和 JavaScript，在此原则下，它们被紧紧地捆在一起，而分离它们是分离技术，这不是关注点。这个概念可以进一步扩展到 CSS，删除 CSS 开发过程中的一连串问题，包括全局命名、作用域/变量的隔离。详细请看：Radium 和 React: CSS in js。 错误的快速隔离 —— Facebook 提供了一个浏览器的扩展应用，帮助开发者更好地查看某一 UI 是由哪些 component 和数据组合生成的。详细请看这里。 简洁明了的代码 —— 当前绝大多数的工具，都是以模型表示数据和视图显示数据结合在一起，从而生成丰富的 UI 交互。通常修改一个模型或视图（例如购物车）就可能在其他视图中触发“级联变化”，同时它依赖的是相同的数据。在一个大型应用中，依赖视图会变得很复杂，而且很难修复那些意想不到的 BUG。但是在 React 中，数据的流向是单向的，因此使得视图更容易理解。下面的图是展示信息的流动。 提高了易测性 —— 一个组件，React 的通常做法是抽象数据参数和输出一个没有其他副作用的 DOM。通过移除依赖使用和在 DOM 中创建 state 的 store，使得这些组件拥有更多的原子和可测试性。 开发团队的效益快捷的管理 —— React 的 API 非常小，结合声明性语法和组件化的 UI 元素使新的开发人员能更快地上手 —— 特别是刚毕业的大学生或是不熟悉前端坏境的开发者。 案例Facebook Ads“It was extremely difficult to change without causing some side effect or bug somewhere else in the application … When the team rebuilt it in React they found that their rate of new bugs being introduced had gone through the floor” -Spencer Ahrens “When a bug did come in it was much easier to figure out what was going wrong and make a targeted fix” -Spencer Ahrens Netflix“React has exceeded our requirements and enabled us to build a tremendous foundation on which to innovate the Netflix experience” Hit Chat“The dev speed we’ve gained…proves that we can release new client features faster and with more confidence on this platform than on any native client.” 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactJS 的学习教程]]></title>
    <url>%2F2015%2F12%2F07%2Fbest-tutorials-to-learn-reactjs%2F</url>
    <content type="text"><![CDATA[当提到为某个应用或网站构建 UI 时，ReactJS 往往是首先列出的最好的 JavaScript 库。首先它是开源的，并且已经在 Instagram 和 Facebook 上得到实践。还有一些著名的网站也使用 ReactJS 去构建他们的 UI，例如 Airbnb，Khan Academy，BBC，Netflix 等等。 如果你仍然在学习 ReactJS 的路上，并用它构建动态的用户界面，这里有一些教程能帮助你加速学习进程。 下面列出的是一些开发者和作者所写的一部分教程，他们能帮你从新手提升到专家。 ReactJs.net 的教程 这是众多版本的 React 教程之一。这个专门为设计师和开发者去“入门” React 和探索其功能而写的。本教程涵盖了利用 ReactJS 库去创建一个全新的 asp.net MVC 网站的完整流程，并且保证了学习的深入浅出。开始一个新项目的基本流程是，安装 React，构建 component，优化等等。 Ken Wheeler - 学习 ReactJS 这是 Ken Wheeler 在 Scotch.io 上发表的一篇很棒的教程。在去年发表的时候至今，已经有超过 200 条的分享，当然这些也只有在开发者社区圈里才会对此感兴趣。可以说这是目前找到的 ReactJS 最好的教程之一。此教程主要分为五个部分，从基础开始，涵盖了什么是 React，虚拟 DOM 是如何工作的，如何构建页面，生命周期的说明和 state 等。 第二部分则介绍了一些高级的概念，例如 Flux，dispatcher，视图控制器的依赖等等。第三，第四和第五部分主要是用 30 分钟去教你如何开发一个具有购物车的 ReactJS 应用，构建一个实时的 Twitter 流，以及开发一个移动应用。 Jack Callister - React 的快速入门 如果你正在寻找一个如何使用 React 库的快速指南，这会是一个很好的地方。这篇文章发布在 Jack Callister 的个人博客中。这篇文章并是不是很出名，但它对于学习基础知识已经足够了。作者写时主要描述 react element，component，JSX 和虚拟 DOM 的基础概念。当你理解了这些概念，就可以很轻松地构建一系列的用户界面。作者首先解释了渲染，然后是 component，props，state 和合成。 本文的另一个观点是，它充满了有用的工具链接，ReactJS 资源和信息。ReactJs 的初学者绝对值得一读! Leveluptuts - React for Everyone 此教程的本质是提供给任何一个学习 ReactJS 的人，无论是初学者还是高手。这里面有一系列的视频来做介绍，并且涵盖了入门和理解这个库的基础知识。 在第二章中我们会得到很有趣的部分，教你如何构建你的第一个 react 组件。其余章节包含了 react component properties，JSX 的条件语句，父子组件的关系和使用 state。这些都是必看的视频。 ReactJS 入门级教程 这是入门 ReactJS 的另一个很好的教程。这是只是三部分的第一部分。对于新人学习基础知识而言这是很棒的一部分。开始介绍了什么是 React，虚拟 DOM 的概念，然后就是如何在服务端做渲染，组件驱动的开发，还有一点关于 JSX 和有用的链接等。 这其实是一个“入门级”课程的详细教程。在开发 ReactJS 的过程中确保你都看了这些非常有用的资源！ 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>ReactJS</tag>
        <tag>教程</tag>
        <tag>Tutorials</tag>
        <tag>getting started lesson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于 Web 设计师和开发者非常有用的 25 个 Chrome 扩展应用]]></title>
    <url>%2F2015%2F12%2F04%2F25-chrome-extensions-for-web-designers-developers%2F</url>
    <content type="text"><![CDATA[尽管 Chrome 的开发者工具给你足够多的实用工具来覆盖你的设计和开发需求，但也可以通过添加免费的扩展应用去进一步扩展浏览器的功能。根据你的需要，并选择完美的扩展，你可以轻松地创建一个个性化的开发环境，这会大大提高你的开发效率。 要介绍的 25 个 Chrome 扩展应该我们为你选择分为以下几类：前端扩展，在线编辑，验证器与性能相关，测量扩展应用，颜色工具，字体测试工具和 很有用的实用性扩展应用。 前端扩展SnappySnippetSnappySnippet 把 CSS 和 HTML 从 DOM 树里提取出来，然后发送到 CodePen，jsFiddle 或 JS Bin 上。 MagiCSSMagiCSS 一个拥有内置编辑器的在线 CSS 编辑扩展应用，具有美化和减小 CSS 的功能。同时还允许创建 Github Gist。 CSS DigCSS Dig 能够在大多数的网站上找到和组织样式表和样式块，给你一个简单的方法来分析和计划重构的代码。 CSSViewerCSSViewer 能集成很多工具和扩展程序去执行一个简单的任务。这使得它们更好地发挥功能。但没有 Chrome 扩展应用集合能在不集成的情况下可以完成这种功能。用法很简单，你只需点击工具栏的图标，然后将鼠标移到你想审查的元素上就可以了。 CSS-ShackCSS-Shack 帮助你创建图层样式（就像你用如 PS 一样），并能生成一个 CSS 文件。 CSS3 GeneratorCSS3 Generator 如名，可以帮助你生成 CSS3 代码。 CSS Shapes EditorCSS Shapes Editor 在线编辑 CSS 形状的值。 在线编辑WordPress Style EditorWordPress Style Editor 支持在线审查和编辑你的 WordPress 的样式。 PageEditPageEdit 能把 Chrome 变成所见即所得的编辑器，你可以用它编辑任何网页。 验证器与性能相关PerfmapPerfmap 它用 Resource Timing API 来创建一个网站的前端的性能的热图检查的定时器，使得可以在浏览器中查看加载的资源。 ValidityValidity 帮助你验证任何一个网页。可以在 console 页查看错误的数量和详情。 Web Developer ChecklistWeb Developer Checklist 必备的扩展应用，可以查看任何一个网页的报错和反常的问题。 Bootlint This PageBootlint This Page 在 Chrome 浏览器上显示一个按钮，帮助你查看任何一个基于 BootStrap 的网页的报错。可以在 console 页查看。 Check My LinksCheck My Links 扫描网页，并把链接以高亮显示，有效为绿色，无效为红色。没人会喜欢无效的链接！ 测量扩展应用Page RulerPage Ruler 能够在任何网上形成一个画尺，并显示元素的 width，height 和 position。 DimensionsDimensions 简单且使用的工具，为你测量屏幕宽度和高度。 颜色工具ColorZillaColorZilla 起源于 Firefox，但它为 Chrome 增加了多种颜色工具，像吸管，颜色选择器，调色板查看器和梯度生成器。 Color TabColor Tab 在你每次打开一个新标签时，会给你一个美丽的新配色方案。 字体测试工具Fontface NinjaFontface Ninja 可以识别任何网页的字体，同时给出它的 size 和 line-spacing。帮助你测试和探索新的字体。 Font PlaygroundFont Playground 在任何网页上预览 Google 成千上万的字体。 TypeWonderTypeWonder 允许你在任何网站测试 web 字体。输入站点 URL 就可以立马预览字体。 很有用的实用性扩展应用Responsive Web Design TesterResponsive Web Design Tester 是一个简单的工具，来帮助快速、轻松地测试网站在大多数流行的移动设备上的响应。 45to7545to75 为保证在所有大小设备上，你的文字是可读的。它可以帮你把句子规定在 45 到 75 个字符之间，从而优化句子长度。 PerfectPixelPerfectPixel 在开发 HTML 时，它会把半透明图像叠加在顶部，允许你在每个像素间进行比较。 ZenHubZenHub 为 Github 项目管理应用。有节省时间的特性，如 drap-drop 任务板和 to-do 列表，帮助你提升 Github 的生产效率。 Instant WireframeInstant Wireframe 谁不喜欢漂亮的线框呢？它给为任何一个网页添加线框，同时本地的也可以。 Minimalist Markdown EditorMinimalist Markdown Editor 同步预览 Markdown。可以快速地帮 Markdown 转化成 HTML。 fb-flofb-flo 由 Facebook 开发，同时也是 Chrome 的扩展应用。使你能够在线编辑 JS，CSS，images 或任何静态资源。 Web DeveloperWeb Developer 如果你现在还没用这个应用，赶紧吧。这是迄今为止最受欢迎的 Chrome 和 Firefox 开发人员扩展应用。它添加了一个超级有用工具到浏览器，每个网页设计师和开发人员，还有你可能甚至不知道你需要的都会需要。 MySQL AdminMySQL Admin 为你更好地，更简单地管理 MySQL 数据库。 完毕！想要获取更多的 Chrome 扩展应用，请看 DevTools Tips，这里收集了 Chrome 的开发工具集和基本使用方法。如果你是一个设计师或开发人员，想获取更新最新的设计和开发资讯，请访问 Chrome 的扩展应用 Muzli 或 Panda。 如果你正在寻找 Firefox 的扩展应用，请看：对于 Web 开发非常有用的 20 个 Firefox 扩展应用。 之前还有一篇发布在 Speckyboy Design Magazine 上的文章是对于 Web 设计师和开发者非常有用的 20 个 Chrome 扩展应用。 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Web Development</tag>
        <tag>Chrome Extensions</tag>
        <tag>Web Designers</tag>
        <tag>Developers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的新版布局]]></title>
    <url>%2F2015%2F12%2F01%2Fblog-new-layout%2F</url>
    <content type="text"><![CDATA[今天兴致勃勃去查看了下 Next 主题的更新，发现已经有了新的版本，而且布局也更新了。所以马上就试了试，先来看看变化： 旧版 新版 主要改动 修改了 header 的位置和布局 添加了 FontAwsome 的图标 将一部分站点配置，转到 theme 下的 _config.yml 中，如：第三方服务等 添加了阅读次数字段：leancloud_visitors FaceBook SDK 支持：facebook_sdk … 很有很多有趣的变化可以自己去发现，有任何疑问或建议可以在下面评论！同时你也可以去 NexT 作者的博客提问。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>next</tag>
        <tag>hexo</tag>
        <tag>pisces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5 大 Web 开发与设计网站]]></title>
    <url>%2F2015%2F11%2F17%2F5-top-websites-on-web-design-and-development%2F</url>
    <content type="text"><![CDATA[Web 缺点之一是任何东西都是临时的。技术的发展快如闪电，当你想设计一个新的网站，或是让别人为你设计一个，当前的技术将变得不足以应付。本文将为你介绍很多很好的网站。你需要设计一个让读者难忘的，同时能发表一个声明，并且不会像其它网站一样会让你的读者“尖叫”的网站。你要为你的目标读者提供一个独特而不同于其它的体验，否则你会失去这里读者。 如果你是一个 Web 开发人员或是设计师，那么你会喜欢上这 5 个网站，同时你也会拥有一个志同道合的社区，从中受益并且重新概念化你的品牌和业务价值。 WebDesigner News这里将列出设计师们的经验，他们会将自己的经验总结成一些“入门级”的文章。其中有些是高技术含量的文章，但也是与 web-friendly 相关的内容。 Smashing Magazine一个不仅关注编码和设计的全类型网站，但也可以在这里用设计好设计和编码去触动某人。重点是提供可编辑的内容，从设计的角度而言，它可以作用于在两个主要平台——站点和电子书发布。 Dribble一个设计师社区，用于展示和分享他们最新的 Web 设计项目。这为你提供了很多与全球的设计师面对面合作的机会，也可以在此获得设计师工作的机会。 A List Apart专注于 Web 相关的设计，开发及意义。你会在这找到你特别关注的 Web 标准和最佳的实践。这个网站附加的价值是，它会为那些及时书写与主题相关的 Web 设计和开发的自由作家支付一笔钱。鲜明的特点是，所有的专家都是来自世界各地。 Awwwards一个 Web 设计师和开发人员展示它们工作成果的网站，同时也希望自己能被发现，识别和获得升职机会。每年，顶级设计师和开发人员选择在一个标志性的城市举行特殊的颁奖典礼。对于 Awwwards 而言，他们正在寻找有用的，创新的，直观的，美丽的而且独特的数字体验。Awwwards 是一个全球性对于知识和灵感“很好”的网站。 现在你明白了吧——这五大网站，不仅仅是展示人才，同时了解 Web 设计人员和开发人员通过这些网站的功能去概念化品牌的知识。这些网站的许多贡献者最大化他们的在线帮助你去建立品牌和让你成为一个志趣相投的社区的一部分。你听说过或与这些网站吗？你有任何其他人分享吗？加入谈话，在下面的评论栏中分享你的想法。 原文链接]]></content>
      <categories>
        <category>好文分享</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Web Development</tag>
        <tag>Web Dedign</tag>
        <tag>Websites</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git 管理项目 - reset 与 rebase]]></title>
    <url>%2F2015%2F11%2F04%2Fuse-git-reset-and-rebase%2F</url>
    <content type="text"><![CDATA[在日常管理项目的过程中，可能会遇到提交的 commit/merge 并不是想要的，或是操作失误提交了，那么此时我们需要把不想要的 commit/merge 取消掉，如果做到呢？Git 为我们提供了一个 reset command，很好地解决了这个问题。 reset1. 命令说明1$ git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;|&lt;HEAD&gt;] 常用的是 [--hard|soft|mixed]，本文主要使用 --hard 作为例子进行说明。 2. 本地仓库在本地仓库执行 $ git reset --hard HEAD^ 可以将本地的仓库回滚到上一次提交时的状态，HEAD^ 指的是上一次提交。 同时你也可以执行 $ git reset --hard fc232ae 将其回滚到 fc232ae commit 时的状态。 3. 远程仓库以上操作只会对本地仓库造成影响，而远程仓库的源码和 commit 信息并不会因此改变。那么此时我们需要另外一个 command 来改变远程仓库的状态。 注意，此时不要在上一步的操作之后执行 $ git pull ，因为这个操作会使本地仓库的状态与远程同步。1$ git push origin [branch] -f 执行此命令后，Git 会将远程仓库的状态与本地仓库的保持一致，即回滚状态。 在更新代码时，难免一次到位，此时就会生成许许多多的 commit 。比如同一个文件，反复地修改代码，反复地提交，此时会有 5，6 个 commit 甚至更多，那么你会在提交 list 中看到一大串的 commit 记录，会觉得很是头疼，杂乱。此时我们需要把这些 commit 整合以下，合并到一个 commit 中，其他的 commit 都 squash 到第一 commit 中，那么就需要用到 rebase。 rebase1. 说明1$ git rebase -i [branch|&lt;commit&gt;] 你可以直接进入某个分支的 rebase 也可以进入某次 commit 的 rebase，如果你是项将某些 commit 合并，那么建议使用 $ git rebase -i &lt;commit&gt;。 此外 rebase 还提供三个操作命令，分别是 --continue、--absort 和 --skip，这三个命令的意思分别是“继续”、“退出”和“跳过”。 2. 查看记录1$ git log 执行此命令即可看到当前分支下所有的提交记录，然后根据个人需要复制其中的 commit 的 SHA 进行 rebase 操作。 3. rebase执行：1$ git rebase -i 9cbc329 然后就会看到：12345678910111213141516pick fb554f5 This is commit 1pick 2bd1903 This is commit 2pick d987ebf This is commit 3# Rebase 9cbc329..d987ebf onto 9cbc329## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## If you remove a line here THAT COMMIT WILL BE LOST.# However, if you remove everything, the rebase will be aborted.# 那么其中 pick fb554f5 This is commit 1 我们可以把它分成三部分去解释： pick:：操作，即 rebase command fb554f5：commit shortID，提交的简写 ID This is commit 1： commit message，提交时填写的提交信息 此时我们可以看到输出结果中所提供的一些操作方法，比如 pick、squash、edit 等。那么重要的是 pick 和 squash。 接着我们需要把 2bd1903 和 d987ebf 合并到 fb554f5 中，做如下操作（注意：此时是 VIM 的操作界面，熟悉 Linux 的同学可以无视，不熟悉的可以简略的指导）：12345678910111213141516pick fb554f5 This is commit 1squash 2bd1903 This is commit 2squash d987ebf This is commit 3# Rebase 9cbc329..d987ebf onto 9cbc329## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## If you remove a line here THAT COMMIT WILL BE LOST.# However, if you remove everything, the rebase will be aborted.# 在做完以上修改操作后输入 :x 保存文件并退出界面，然后就会看到：123456789101112$ git rebase -i 9cbc329rebase in progress; onto 9cbc329You are currently rebasing branch &apos;master&apos; on &apos;9cbc329&apos;.nothing to commit, working directory cleanThe previous cherry-pick is now empty, possibly due to conflict resolution.If you wish to commit it anyway, use: git commit --allow-emptyOtherwise, please use &apos;git reset&apos;Could not apply 9cbc329f722f8e531496da70ee3857b031574b6d... squash commit on rebase 此时用 $ git status 查看会看到：123456$ git statusrebase in progress; onto 9cbc329You are currently rebasing branch &apos;master&apos; on &apos;9cbc329&apos;. (all conflicts fixed: run &quot;git rebase --continue&quot;)nothing to commit, working directory clean 紧接着我们需要执行 $ git rebase --continue 操作：123456$ git rebase --continue[detached HEAD 2bd1903...d987ebf] squash commit on rebase Date: Tue Nov 3 10:09:43 2015 +0800 1 file changed, 149 insertions(+), 154 deletions(-) rewrite test.js (72%)Successfully rebased and updated refs/heads/master. 最后我们需要把修改合并好的 commit push 到远程仓库上：1$ git push origin [branch] -f 到此为止，整个 rebase 操作都已完成。你会看到类似：变成类似： 简略的指导在 VIM 的操作界面下，需要按 I/Insert 键进行插入修改文本操作，修改完文本之后需要按 Esc 键退出编辑状态，然后输入 :q 是离开，输入 :!q 是强制离开，输入 :x 是保存修改并离开。在 rebase 修改文本结束后需要输入 :x 进行保存。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>项目管理</tag>
        <tag>reset</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts - 数据图表的使用]]></title>
    <url>%2F2015%2F10%2F16%2Fuse-echarts%2F</url>
    <content type="text"><![CDATA[关于ECharts（ECharts）ECharts 是百度提供的一款开源、功能强大的数据可视化产品。主要提供折线图、柱状图、散点图、K线图、饼图、雷达图、地图、和弦图、力导向布局图、仪表盘以及漏斗图。 特性 拖拽重计算 数据视图 多图联动 值域漫游 炫光特效…… 准备下载 ECharts 静态包【echarts-2.2.7】，也可以直接使用链接进行加载。建议下载静态包，避免官方 更新新特性 时造成图表无法正常呈现的问题。 使用ECharts的使用很简单，以官方提供的为例分为下面几步： 1. 新建一个 test.html 并放置一个 div 来承载图表：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="main" style="height: 400px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 引入 echarts.js ：1&lt;script src=&quot;http://echarts.baidu.com/build/dist/echarts.js&quot;&gt;&lt;/script&gt; 3. 添加模块加载器配置 echarts 和所需图表的路径（相对路径为从当前页面链接到echarts.js），引入图表文件见引入 ECharts2：12345678&lt;script type=&quot;text/javascript&quot;&gt; // 路径配置 require.config(&#123; paths: &#123; echarts: &apos;http://echarts.baidu.com/build/dist&apos; &#125; &#125;);&lt;/script&gt; 4. 动态加载echarts和所需图表，回调函数中可以初始化图表并驱动图表的生成，option见API &amp; Doc：12345678910111213141516171819202122232425262728293031323334353637383940require( [ &apos;echarts&apos;, &apos;echarts/chart/bar&apos; // 使用柱状图就加载bar模块，按需加载 ], function (ec) &#123; // 基于准备好的dom，初始化echarts图表 var myChart = ec.init(document.getElementById(&apos;main&apos;)); var option = &#123; tooltip: &#123; show: true &#125;, legend: &#123; data:[&apos;销量&apos;] &#125;, xAxis : [ &#123; type : &apos;category&apos;, data : [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125; ], yAxis : [ &#123; type : &apos;value&apos; &#125; ], series : [ &#123; &quot;name&quot;:&quot;销量&quot;, &quot;type&quot;:&quot;bar&quot;, &quot;data&quot;:[5, 20, 40, 10, 10, 20] &#125; ] &#125;; // 为echarts对象加载数据 myChart.setOption(option); &#125;); 5. 最后的样子： 重点- option 部分相关配置说明用户可以在 option 配置里自定义图标的样式。 title 标题： 1234title : &#123; text: &apos;某地区蒸发量和降水量&apos;, //文本 subtext: &apos;纯属虚构&apos;&#125; toolbox 便捷的工具： 12345678910toolbox: &#123; show : true, //是否显示工具栏 feature : &#123; //特性 mark : &#123;show: true&#125;, //辅助线 dataView : &#123;show: true, readOnly: false&#125;, //数据视图 magicType : &#123;show: true, type: [&apos;line&apos;, &apos;bar&apos;]&#125;, //切换视图（折线/柱状） restore : &#123;show: true&#125;, //重新加载视图 saveAsImage : &#123;show: true&#125; //保存该视图为图片 &#125;&#125; series 数据列表： 1234567891011121314151617series : [&#123; name:&apos;蒸发量&apos;, //名称 type:&apos;bar&apos;, //视图类型 data:[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3], //数据 markPoint : &#123; //标记 data : [ &#123;type : &apos;max&apos;, name: &apos;最大值&apos;&#125;, //最大值，name为显示文本 &#123;type : &apos;min&apos;, name: &apos;最小值&apos;&#125; //最小值，name为显示文本 ] &#125;, markLine : &#123; //标线 data : [ &#123;type : &apos;average&apos;, name: &apos;平均值&apos;&#125; //平均值，name为显示文本 ] &#125;&#125; xAxis ： X 轴 yAxis ： Y 轴 legend ：12345legend: &#123; orient : &apos;vertical&apos;, //方向“垂直”，默认从左向右横向排列 x : &apos;left&apos;, //位于 X 轴左侧，默认顶部居中 data:[&apos;直接访问&apos;,&apos;邮件营销&apos;,&apos;联盟广告&apos;,&apos;视频广告&apos;,&apos;搜索引擎&apos;] //显示文本&#125; 更多配置可在【实例】中点开测试。 参考 入门教程 实例 Fork on github]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>ECharts</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新 Github 的 Fork 代码]]></title>
    <url>%2F2015%2F10%2F06%2Fuse-git-update-fork-code%2F</url>
    <content type="text"><![CDATA[github 提供了一个非常便捷的功能叫 Fork，即用户可以很方便的从别的仓库中复制一份代码到自己的名下。但是有一个不足是 github 并不提供自动更新功能，那么此时就需要我们自己手动更新这个 Fork 仓库代码。 基本方法 安装 github客户端 或者 Git。 clone 需要更新的 Fork 分支到本地： github客户端：直接打开客户端，添加 Fork 分支，然后 clone。 Git命令：1$ git clone git@github.com:yourname/repos.git &lt;yourfolder&gt; 注：github客户端 clone 成功后，可以使用 git bash 进行命令行输入。 将源分支添加到该仓库的远程分支中： 1$ git remote add author git@github.com:author/repos.git 此时可以使用 $ git remote -v 查看远程分支列表，结果如下： 1234author git@github.com:author/repos.git (fetch)author git@github.com:author/repos.git (push)origin git@github.com:yourname/repos.git (fetch)origin git@github.com:yourname/repos.git (push) fetch 源仓库代码的最新版本到本地： 1$ git fetch author //这里的`author`是上面从源分支添加到远程分支的分支名 合并两个版本的代码： 1$ git merge author/master 将本地代码更新到 Fork 仓库： 1$ git push origin master 其他方法重复上述的1-3，然后使用 git pull author master 把源仓库的最新代码拉下来，然后使用第6步的方法，将代码推到自己的 fork 的仓库中。]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo + NexT 搭建静态博客]]></title>
    <url>%2F2015%2F09%2F18%2Fuse-hexo-and-next-to-build-blog%2F</url>
    <content type="text"><![CDATA[前言Github 为广大开发者提供了一个非常好的平台，不仅是代码的开源，同时 Github 还提供了开发者可以在 Github 上建立自己的站点（GithubPage）的一个非常有意思的功能。这个功能的局限是只能创建静态的网站，那么我们可以使用一些工具来快速创建这一网站。本文旨在帮助刚接触 Github 新手，想利用 Github 来创建自己的站点、个人博客等。大神可以忽视(:з」∠)。 准备你需要在 Github 上创建一个属于自己的账户，然后新建一个仓库（new repository），并命名为 YourSiteName.github.io/com，此时 Github 会帮助你初始化一个静态网页，你可以根据自己的喜好选择一些模版（这都不是重点），接着尝试访问下你所建的站点，成功后就可以开始动工了。 关于 Hexo A fast, simple &amp; powerful blog framework 快速，简单而高效的静态博客框架 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 关于NexT NexT is built for easily use with elegant appearance. First things first, always keep things simple NexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。 这是一个扩展主题，由 iissnan 开发，精于心，简于形的理念。 正题上面是对搭建博客的一些技术了解，接下来进入正题。 Hexo 初始化博客框架1. 安装 HexoHexo 安装和搭建依赖 Nodejs 和 Git ，可自行下载。1$ npm install -g hexo-cli 2. 初始化框架123$ hexo init &lt;yourFolder&gt;$ cd &lt;yourFolder&gt;$ npm install 初始化完成大概的目录：12345678.├── _config.yml //网站的 配置 信息，您可以在此配置大部分的参数。├── package.json├── scaffolds //模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source //资源文件夹是存放用户资源的地方。| ├── _drafts| └── _posts└── themes //主题 文件夹。Hexo 会根据主题来生成静态页面。 3. 新建文章（创建一个 Hello World）1$ hexo new &quot;Hello World&quot; 在 /source/_post 里添加 hello-world.md 文件，之后新建的文章都将存放在此目录下。 4. 生成网站1$ hexo generate 此时会将 /source 的 .md 文件生成到 /public 中，形成网站的静态文件。 5. 服务器1$ hexo server -p 3000 输入 http://localhost:3000 即可查看网站。 6. 部署网站1$ hexo deploy 部署网站之前需要生成静态文件，即可以用 $ hexo generate -d 直接生成并部署。此时需要在 _config.yml 中配置你所要部署的站点： 12345## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:YourRepository.git branch: master 7. 更多 官网 - [Hexo] 配置相关 - [Hexo | 配置] 更多的命令 - [Hexo | 指令] 那么到此为止网站的雏形算是完成了，接下来你就要自己去管理和完善个人网站了。 使用 NexT 主题让站点更酷炫1. 使用12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 从Next的 Gihub 仓库中获取最新版本。 2. 启用需要修改 /root/_config.yml 配置项 theme：1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next 3. 验证是否启用1$ hexo s --debug 访问 http://localhost:4000，确保站点正确运行。（此命令可以做平时预览用） 4. 更多 Next官网 - [NexT] 主题设定 - [NexT | 主题设定] 第三方服务 - [NexT | 第三方服务] 启用 NexT 主题成功，那么你的网站变得酷炫（简约）。 最后我的博客NexT 官方实例 有任何疑问和建议可以留言，将在第一时间为你解答]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 一些常用命令]]></title>
    <url>%2F2015%2F09%2F17%2Fuse-npm-command%2F</url>
    <content type="text"><![CDATA[关于NPMNPM 的全称是 Node Package Manager，是一个 NodeJS 包管理和分发工具，已经成为了非官方的发布 Node 模块（包）的标准。就目前而言，NPM 的官网[1]拥有 18 万的 packages。国内的镜像是淘宝所提供的 CNPM[2]，与 NPM 相同，它会每隔 10 分钟就同步一次。 一些常用命令 npm -v: 查看 npm 安装的版本 npm init: 引导你创建一个 package.json 文件，包括名称、版本、作者这些信息等 npm install &lt;modulename&gt;: 安装模块 npm install &lt;modulename&gt; -g: 安装全局模块 npm install &lt;modulename&gt;@1.0.0: 安装指定版本的模块 npm install &lt;modulename&gt; -save: 安装模块并添加到 package.json 依赖中 npm uninstall &lt;modulename&gt;: 卸载模块 npm cache clean: 清除缓存 npm help: 查看帮助命令 npm ls: 查看当前目录安装的依赖 npm ls -g: 查看全局目录安装的依赖 npm view &lt;modulename&gt;: 查看包的 package.json npm view &lt;modulename&gt; dependencies: 查看包的依赖关系 npm view &lt;modulename&gt; repository.url: 查看包的源文件地址 npm update &lt;modulename&gt;: 更新模块 npm remove &lt;modulename&gt;: 移除模块 题外话CNPM有时候会出现NPM无法使用的情况，此时可以尝试使用 CNPM 解决此问题。 淘宝NPM镜像这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10 分钟一次以保证尽量与官方服务同步。 使用1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装模块与NPM类似，将npm install &lt;...&gt;改为cpm install &lt;...&gt; 更多更多命令参考文档[3]]]></content>
      <categories>
        <category>开发日常</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>module</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brunch：快捷的HTML5构建工具]]></title>
    <url>%2F2015%2F09%2F08%2Fuse-brunch%2F</url>
    <content type="text"><![CDATA[了解 Brunch（官方介绍） 编译你的脚本，模板，样式，链接它们 将脚本和模板封装进 common.js/AMD 模块里，链接脚本和样式 为链接文件生成源地图，复制资源和静态文件 通过缩减代码和优化图片来收缩输出，看管你的文件更改 并且通过控制台和系统提示通知你错误 安装当你已经拥有 Nodejs 时（若没有，请到 nodejs 官网下载），就可以直接使用 npm 运行：1$ npm install -g brunch 新建 new 新建一个 Brunch1$ brunch new &lt;skeleton-URL&gt; [optional-output-dir] new 可以简写为 n。&lt;skeleton-URL&gt; 指定一个架构，则项目会应用此架构进行初始化。[optional-output-dir] 指定输出目录，项目名称可以自定义。 例如：1234$ brunch n https://github.com/scotch/angular-brunch-seed myProject08 Sep 12:20:32 - log: Cloning git repo &quot;https://github.com/scotch/angular-brunc h-seed&quot; to &quot;E:\myProject&quot;...08 Sep 12:20:49 - log: Created skeleton directory layout08 Sep 12:20:49 - log: Installing packages... 当不指定输出文件夹时，必须保证放置新项目的文件夹为空，否则会 clone 失败。 构建 build1$ brunch build --production 也可以简写为：1$ brunch b -P 这样构建一个分布式项目，使得项目的体积变小。 使用 watch1$ brunch watch --server 也可以简写为：1$ brunch w -s 让 Brunch 看管你的项目，然后你就可以运行项目了。输出结果如：12308 Sep 12:32:58 - error: &#123; [Error: Component must have &quot;E:\w\bower_components\console-polyfill\bower.json&quot;] code: &apos;NO_BOWER_JSON&apos; &#125;08 Sep 12:32:59 - info: application started on http://localhost:3333/08 Sep 12:33:00 - warn: &apos;test\karma-e2e.conf.js&apos; compiled, but not written. Check your javascripts.joinTo config. 注意 必要安装项Git 安装：Gitbower 安装： 1$ npm install -g bower 运行项目前执行 $ bower install 对项目初始化。 参考【官网】【README】【Command】]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>Brunch</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git 管理项目 - 初始化]]></title>
    <url>%2F2015%2F09%2F07%2Fuse-git-initialize%2F</url>
    <content type="text"><![CDATA[获取 Git 仓库获取 Git 仓库的方式主要分为两种。第一种是在现有项目或目录下导入所有文件到 Git 中；第二种是从一个服务器克隆一个现有的 Git 仓库。 GIT INIT首先在现有的项目目录下输入：1$ git init 这样就简单将你的目录转变成一个Git仓库。该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。12$ git add . //`.` 是将目录的所有文件都添加（不包括空文件夹）$ git commit -m &apos;first commit&apos; //提交修改（`&apos;first commit&apos;` 为注释信息） 此时可以使用 $ git status 来查看当前文件状态。我们还可以将项目加入到远程Git仓库：12$ git remote add origin git@github.com:jovey-zheng/test.git //加入到远程的 Git 仓库$ git push -u origin master //将项目推到 Git 仓库 这样我们就可以实现项目的远程操作。 GIT CLONE当远程 Git 仓库已经存在一个项目时，需要对此项目进行操作；或者有一个你想为此贡献自己一份力的开源项目时，就需要用到 $ git clone。当你执行 $ git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 克隆仓库的命令格式为 $ git clone [url]。例如，要克隆 Git 的可链接库 test，可以用下面的命令：1$ git clone git@github.com:jovey-zheng/test.git 这会在当前目录下创建一个名为 test 的目录，并初始化一个 .git 文件夹。如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：1$ git clone git@github.com:jovey-zheng/test.git myTest 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 myTest。 Git 支持多种数据传输协议。上面的例子使用的是 SSH 传输协议，当然也可以使用 https:// 协议。 关于SSH：《SSH key 生成》推荐：《Git pro》]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成 SSH keys]]></title>
    <url>%2F2015%2F09%2F07%2Fuse-git-generate-ssh-key%2F</url>
    <content type="text"><![CDATA[首先确认自己的系统中是否已经拥有密钥。在默认情况下SSH的密钥存储在其 ~/.ssh 目录下。可以使用以下命令进入目录并列出内容：1234$ cd ~/.ssh$ lsid_rsa id_rsa.pub known_hosts 其中 id_rsa 和 id_rsa.pub 就是存储密钥的文件，带有 .pub 后缀的是公钥，另外一个则是私钥。如果存在这些文件，则可以直接用 $ cat id_rsa.pub 来读取密钥内容。如果找不到这样的文件（或者不存在 ~/.ssh 目录），则可以通过 $ ssh-keygen 来创建它们。1234567891011$ ssh-keygen -t rsa -C `you@email.com`Generating public/private rsa key pair.Enter file in which to save the key (/home/schacon/.ssh/id_rsa):Created directory &apos;/home/schacon/.ssh&apos;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/schacon/.ssh/id_rsa.Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.The key fingerprint is:d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 you@email.com 首先 $ ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可（为了方便以后操作，建议不设置密码）。 在完成上述操作之后即可获得 SSH key，获得的公钥大概是这样的：12345678$ cat id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAmzM2RosSFanpxK+d3Eagt3Wicef9QbgH1x4yH3MFg2+6vIuFXchl+L3gMZabWH3BzKpBwoJICg8q9k4N8nOf5LNPtIp74hnEj/1b9Nh7OLrri82Ao6FYEdkC0NVsfhKlqha10MQrYxctimabtuKZdoUvv0knSawwvql2mvCIDra2D2350ICycZi0Fg1QULF3QdDF8Emtnvso1a5a9jgzf3tyHX6+r7lGnA+Ifzr8bxC4sqZ+aN0R7dn4uqQETF7l+n16dd370Efvbvj8CabZqVs7r5j/fdltcmSrH3i97Yfq0XsM0CIxltOIb8+MhkRzHAXdjWY51LyfyHtyysbgHw==you@email.com 关于在多种操作系统中生成 SSH 密钥的更深入教程，请参阅 GitHub 的 SSH 密钥指南：https://help.github.com/articles/generating-ssh-keys]]></content>
      <categories>
        <category>笔记随笔</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>git</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git 管理项目 - 起步]]></title>
    <url>%2F2015%2F09%2F07%2Fuse-git-starter%2F</url>
    <content type="text"><![CDATA[关于版本控制提到版本控制，那么我会想到的是 SVN 以及这里要说的 Git。那什么是版本控制呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 Git基础-三种状态Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下：123451.在工作目录中修改文件。2.暂存文件，将文件的快照放入暂存区域。3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 如何安装Git Mac: brew install git Linux(Debian) : apt-get install git-core Linux(Fedora) : yum install git-core Windows : 下载安装 Git 配置1$ git config --global user.name &quot;your name&quot; 1$ git config --global user.email &quot;youremail@email.com&quot; 使用 --global 可以使该命令只执行一次。 你可以通过如下的命令来查看你的配置信息：123456789$ git config --listuser.email=joveyzheng@qq.comuser.name=joveyzhengcolor.status=auto... 你可以通过输入 $ git config &lt;key&gt; 来查看某一项的配置123$ git config user.namejoveyzheng 获取帮助1$ git help 文中多处借鉴《Git pro》，想获得更多了解推荐阅读： Git Pro]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
</search>